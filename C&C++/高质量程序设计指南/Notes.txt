1.在使用运算符“&&”的表达式中，要尽量把最有可能成为False的子表达式放在“&&”的左边；同样在使用运算符“||”的表达式中，要尽量把最有可能成为“True”的子表达式放在“||”的左边。因为C++/C对逻辑表达式的判断采取“猝死法”：如果“&&”左边的子表达式计算结果为False，则整个表达式就为False，后面的子表达式就没有必要再计算；如果“||”左边的子表达式计算结果为True，则整个表达式就为True，因此后面的子表达式没有必要再计算。这种方法可以提高程序的执行效率。
2.在if/else结构中要尽量把True概率较高的条件判断置于前面，可以提高if/else结构效率。
3.不能在类声明中初始化非静态const数据成员。eg.
  class A
  {
      ...
      const int SIZE = 100;    // 错误，企图在类声明中初始化const数据成员
      int array[SIZE];            // 错误，未知的SIZE
  };
非静态const数据成员的初始化只能在类的构造函数的初始化列表中进行。eg.
  class A
  {
      ...
      A(int size);
      const int SIZE;
  };
  A::A(int size):SIZE(size)
  {
      ...
  }
4.枚举变量不会占用对象的存储空间。
5.在指针参数或引用参数只作为输入时，尽量使用const限制，避免被修改。若作为输出时，添加const限制的话，该参数将失去输出功能。若参数为值传递，因为本身就是使用的变量的copy，即使修改了，原参数也不会变，因此不需要进行const限制。
6、虽然类型名和“*”的组合是一种指针类型，但是编译器解释的时候，“*”是和其后的变量名结合的。例如：
    int*     a,b,c;
编译器会理解为：
    int     *a,b,c;
即只有a是int类型的指针，而b和c仍然是int类型的变量。
7、void*类型的指针不能参与算术运算，只能进行赋值、比较和sizeof()操作。
8、当把“*”用于指针时，就是在提取指针所指向的变量。因此在将“*”用于指针时一定要确保该指针指向一个有效的和合法的变量。不能对void*类型指针使用“*”来取其所指向的变量。
9、引用一旦初始化为指向一个对象，它就不能被改变为对另外一个对象的引用；而指针在任何时候都可以改变为指向另一个对象。给引用赋值并不是改变它和原始对象的绑定关系，例如：
    int a=10, b=100, c=1000;
    int& rInt = a;	// rInt = 10;
    rInt = b;           // rInt = 100, a = 100;
    int *p = &c;	// *p = 1000, c=1000;
    p = &b;		// *p = 100, c=1000;